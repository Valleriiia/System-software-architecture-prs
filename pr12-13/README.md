# Практична робота №10

**Тема:** Звіт з теми "Сигнали в Unix"

---

## Приклади 1-2: Обробка простих сигналів (SIGINT, SIGTERM)

Було реалізовано програми, які перехоплюють сигнали `SIGINT` (Ctrl+C) та `SIGTERM`, використовуючи функцію `signal()`. При отриманні сигналу `SIGINT` програма не завершувалася, а лише виводила повідомлення. Для `SIGTERM` — програма завершувалася через `_exit()`. Також було реалізовано виведення PID, що дозволяло надіслати сигнал з іншого термінала. Під час виконання завдання вивчено базову модель роботи обробників сигналів і асинхронну природу їхнього виклику.

---

## Приклад 3: Маскування сигналів (`sigprocmask`)

Реалізовано приклад блокування сигналу `SIGINT` за допомогою `sigprocmask()`. Було показано, як сигнал може бути тимчасово заблокований, а потім — після розблокування — оброблений. Це дозволяє захищати критичні ділянки коду від небажаних переривань. Вивчено роботу з `sigset_t`, функціями `sigemptyset()` та `sigaddset()`.

---

## Приклад 4: Уникнення зомбі (`SIGCHLD` + `SA_NOCLDWAIT`)

Реалізовано приклад з використанням `sigaction()` із прапором `SA_NOCLDWAIT` і обробником `SIG_IGN`, що дозволяє уникнути створення зомбі-процесів після завершення дочірніх. Програма створює дочірній процес за допомогою `fork()` і дозволяє переконатися, що після його завершення не залишається запису в таблиці процесів. Це завдання поглибило розуміння життєвого циклу процесів і взаємодії батьківського та дочірнього процесу через `SIGCHLD`.

---

## Приклад 5: Обробка `SIGSEGV` і `siginfo_t`

Реалізовано ловлю `SIGSEGV` з доступом до `siginfo_t`. Виведено адресу порушення доступу до памʼяті через `si_addr`. Це показало, як отримати діагностичну інформацію під час краху.

---

## Приклад 6: Зчитування регістрів із `ucontext_t`

В обробнику `SIGSEGV` доступ отримано до `ucontext_t`, зчитано регістр `RIP` (на x86_64). Демонструє низькорівневий аналіз аварійного завершення процесу з доступом до машинного стану.

---

## Приклад 7: `nanosleep()` із обробкою сигналів

Програма використовує `nanosleep()` у циклі, перевіряючи `errno == EINTR`, що дозволяє правильно продовжити паузу після сигналу.

---

## Приклад 8: subscriber + publisher

У цьому прикладі реалізовано взаємодію між двома процесами за допомогою сигналу `SIGRTMIN`. Підписник (`subscriber`) встановлює обробник сигналу через `sigaction` з прапором `SA_SIGINFO` і виводить номер сигналу, PID відправника та передане значення. Видавець (`publisher`) надсилає сигнал через `sigqueue`, передаючи значення `42`. Це демонструє можливість передавати дані разом із сигналами в реальному часі. Сигнали `SIGRTMIN` є черговими, тому не втрачаються при високому навантаженні. Такий підхід може бути використаний для простого IPC без сокетів чи пайпів.

---

## Приклад 9: Синхронна обробка сигналів (`sigwaitinfo`)

Реалізовано приклад, який блокує сигнали `SIGUSR1` і `SIGUSR2`, виводить відкладені сигнали за допомогою `sigpending()`, а потім виконує синхронне очікування одного з них через `sigwaitinfo()`. Це дозволило продемонструвати ситуацію, коли сигнал доставлено, але не оброблено через маскування, і лише `sigwaitinfo()` дозволяє його перехопити. Таким чином, вивчено альтернативний підхід до обробки сигналів без використання асинхронних обробників.

---

## Завдання 16: Відстеження заблокованих, доставлених, але не оброблених сигналів

Окремо реалізовано завдання, в якому блокуються сигнали `SIGUSR1`/`SIGUSR2`, викликається `sigpending()` для перевірки їхньої наявності, і далі використовується `sigwaitinfo()` для очікування одного з них. Таким чином показано повний цикл: блокування → доставка → фіксація як pending → обробка вручну. Це завдання об'єднує в собі практичне використання кількох функцій одночасно: `sigprocmask`, `sigpending`, `sigaction`, `sigwaitinfo`.

---

# Висновок

У ході виконання цієї практичної роботи:

* Розглянуто як **базові** (signal, SIGINT), так і **розширені** (sigaction, sigqueue, ucontext\_t) інструменти для обробки сигналів у Unix.
* Продемонстровано **всі основні патерни роботи з сигналами**: блокування, відкладення, обробка, краш-діагностика, міжпроцесна передача.
* Отримано навички побудови **надійної сигнал-безпечної логіки**, з урахуванням обмежень на асинхронність і повторний вхід.
* Всі приклади адаптовані для **POSIX-сумісного середовища Linux**, перевірені в WSL.
