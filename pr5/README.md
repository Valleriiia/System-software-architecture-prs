# Практична робота №5
## Приклад з `memcpy()` та помилкою вирівнювання памʼяті в Linux

### Тема

**Помилки роботи з пам’яттю в Linux та засоби їх усунення.**  
Мета: продемонструвати, як функція `memcpy()` може призводити до пошкодження пам’яті при неправильному вирівнюванні структури.

---

### Опис програми

У програмі створюється структура `Data`, яка містить один `char` та одне `double`:

```c
struct Data {
    char a;
    double d;
};
```

Змінна типу `double` вимагає вирівнювання по 8 байтах. Однак у програмі виділяється динамічна памʼять і навмисно зміщується на 1 байт, порушуючи це вирівнювання:

```c
char *buffer = malloc(sizeof(struct Data) + 1);
void *unaligned_ptr = buffer + 1;
```

Далі в памʼять за невирівняною адресою копіюється структура за допомогою `memcpy()`:

```c
memcpy(unaligned_ptr, &source, sizeof(struct Data));
```

І потім програма намагається прочитати значення `double` із цієї адреси:

```c
struct Data *dest = (struct Data *)unaligned_ptr;
printf("d = %f\n", dest->d);
```

---

### Проблема

Таке читання `double` із невирівняної адреси — це **undefined behavior (UB)** згідно стандарту C.

На **архітектурах із суворими вимогами до вирівнювання** (наприклад, ARM, SPARC), це призводить до **сегментаційної помилки або аварійного завершення програми**.

На **x86_64 (Intel/AMD)** така операція **може пройти без помилок**, але:
- Це **небезпечно** і непередбачувано
- Може бути **повільніше**
- Складно виявити без спеціальних інструментів

---

### Виявлення помилки

Для виявлення цієї помилки було використано:

#### `-fsanitize=undefined`:

При компіляції з ключем:

```bash
gcc -Wall -Wextra -O0 -g -fsanitize=undefined -std=c11 memcpy_misaligned.c -o memcpy_misaligned
```

На етапі виконання отримаємо:

```
runtime error: load of misaligned address 0x... for type 'double', which requires 8 byte alignment
```

Це підтверджує, що програма використовує невірно вирівняну пам’ять.

---

### Результати запуску

#### На x86_64:

- Програма зазвичай **не аварійно завершується**
- Значення `double` може бути **спотворене**
- Проблема проявляється лише при використанні `-fsanitize=undefined`

#### На ARM / емуляторі:

- **Аварійне завершення програми** (`Bus error` або `Segfault`)

---

### Правильне вирішення

Щоб уникнути подібних помилок, треба завжди дотримуватися вирівнювання:

#### 1. **Використовувати вирівняне виділення пам’яті**:

```c
struct Data *aligned = aligned_alloc(alignof(struct Data), sizeof(struct Data));
```

#### 2. **Або використовувати `posix_memalign`:**

```c
struct Data *aligned_ptr;
posix_memalign((void**)&aligned_ptr, alignof(struct Data), sizeof(struct Data));
```

#### 3. **Або просто не використовувати `memcpy()` для структур з вирівнянням**, якщо не впевнені в адресі.

---

### Висновок

Ця програма демонструє важливість дотримання **вирівнювання пам’яті при роботі з `memcpy()`** та структурами, що містять типи з вимогами до вирівнювання (`double`, `long long`, SIMD тощо).

Хоча на деяких архітектурах проблема може не проявлятись явно, вона лишається **небезпечною** і призводить до **undefined behavior**, що суперечить стандарту мови C та ускладнює портабельність коду.
