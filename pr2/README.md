# Практична робота №2
Цей звіт охоплює виконання завдань, що були частинами практичної роботи №2 з аналізу структури ELF-файлів у Linux та дослідження деяких специфічних аспектів роботи з процесами. У роботі було використано інструменти, такі як `gstack`, `gdb`, `readelf`, `ls`, а також безпосередній аналіз різних сегментів ELF-файлу.

## Завдання 1: Аналіз ELF-файлу
У першому завданні ми досліджували структуру ELF-файлу за допомогою інструментів size та readelf. Було проаналізовано такі сегменти як:

`.text`: вміст цього сегмента містить скомпільований код програми. Його розмір залежить від кількості та складності функцій у програмі.

`.data`: тут зберігаються ініціалізовані глобальні змінні, і, відповідно, зміна цих змінних безпосередньо впливає на розмір цього сегмента.

`.bss`: цей сегмент включає неініціалізовані змінні. Цікаво, що його розмір визначається лише в процесі виконання програми, і в статичному аналізі він може бути порожнім.

Завдяки цьому аналізу можна зрозуміти, як різні параметри компіляції (наприклад, з опціями `debug` чи `optimize`) можуть впливати на розмір цих сегментів.

## Завдання 2.2: Аналіз стеку процесу через gstack та GDB
У завданні 2.2 ми виконували моніторинг і аналіз стеку процесу через інструменти `gstack` і `gdb`. Це дозволяє отримати інформацію про поточний стан виконання програми на момент її зупинки, а також визначити поточну команду, яку виконує процес.

## Завдання 2.3: Аналіз можливості обходу без лічильника команд
Завдання 2.3 фокусувалося на тому, як можна обходити виконання програми без точного лічильника команд (IP). Цей аспект є важливим для розуміння роботи процесора і може бути використаний для оптимізації роботи програми або, наприклад, для реалізації технік обходу програмної безпеки.

## Завдання 2.4: Зміна сегмента коду через mremap
Завдання 2.4 було присвячене дослідженню техніки зміни сегмента коду через використання системного виклику `mremap`. Це дозволяє модифікувати ділянки пам'яті, що містять код програми, що є важливим для реалізації певних видів атак, таких як переписування пам'яті під час виконання.

## Завдання 2.5: Порівняння та аналіз змінних в ELF-файлі
Ні, у загальному випадку неможливо повністю замінити лічильник команд (IP) лише вершиною стека, тому що:
1. IP вказує на поточну інструкцію, яка виконується. Стек — лише допоміжна структура для збереження адрес повернення при викликах функцій (і ще деяких речей — локальних змінних, регістрів).
2. Процесор читає інструкції із памʼяті послідовно за IP. Без IP він не знає, де шукати наступну інструкцію.
3. Стек не є основним механізмом керування потоком — він лише зберігає адреси повернення. Він не містить всі інструкції, які слід виконати.

## Завдання 16 (варіантне): Аналіз таблиці символів ELF-файлу
У варіантному завданні було здійснено аналіз таблиці символів ELF-файлу. Це включає дослідження того, як символи використовуються для вирішення адрес у програмі і як ця таблиця дозволяє зв'язувати функції та змінні під час виконання.

## Висновки
У результаті виконання практичної роботи вдалося глибше зрозуміти структуру ELF-файлів та важливість правильного управління пам'яттю в операційних системах Linux. Аналіз таких сегментів як `.text`, `.data` та `.bss` дозволяє зрозуміти, як програма використовує пам'ять і як це може впливати на її виконання. Також робота з `gdb` та іншими інструментами дозволяє здійснювати більш гнучке налагодження та оптимізацію програм.