# Практична робота №8 
**Тема:** Системні виклики в UNIX/POSIX (файлові операції, fork(), qsort(), write(), read(), lseek() тощо)

---

## Завдання 8.1

Було розглянуте питання: чи може системний виклик  
`count = write(fd, buffer, nbytes);`  
повернути значення `count`, відмінне від `nbytes`.  

Відповідь: **Так, може**. Це трапляється у випадках:
- Якщо файлова система заповнена.
- Якщо з'єднання (наприклад, сокет або pipe) обмежує обсяг переданих даних.
- Якщо файл відкрито у неблокуючому режимі (`O_NONBLOCK`) і в буфері недостатньо місця для повного запису.
- При сигналі, який перериває `write` (наприклад, `SIGINT`).

Було створено програму, що демонструє приклад часткового запису в pipe, де `write` повертає менше байтів, ніж було запрошено.

---

## Завдання 8.2

Було розглянуто задачу із переміщенням покажчика файлу через `lseek` та подальшим читанням `read`.  
У файлі розміщено послідовність байтів:  
`4, 5, 2, 2, 3, 3, 7, 9, 1, 5`.

Після виклику:  
```c
lseek(fd, 3, SEEK_SET);
read(fd, &buffer, 4);
```  
покажчик файлу переміщується на третій байт (тобто на байт із значенням `2`, враховуючи нумерацію з нуля), і далі читаються наступні 4 байти. Буфер після читання містить значення:  
`2, 3, 3, 7`.

Це було перевірено на практиці через програму, яка відкриває файл, виконує `lseek` і `read`, а потім виводить вміст буфера.

---

## Завдання 8.3

У цьому завданні було досліджено алгоритм швидкого сортування (qsort) і пошук вхідних даних, що змушують його працювати максимально повільно.  

Результат:
- Найгірші дані для класичного QuickSort — це вже **відсортовані** або **обернено відсортовані** масиви.
- Також погано працюють масиви з великою кількістю однакових елементів.

Було створено програму, яка:
- Автоматично генерує різні вхідні дані (вже відсортовані, обернено відсортовані, однакові значення).
- Заміряє час роботи `qsort`.
- Визначає, які масиви найбільше сповільнюють сортування.

Крім цього, був розроблений набір тестів для перевірки правильності сортування, який включає:
- Порожній масив.
- Один елемент.
- Декілька елементів у випадковому порядку.
- Вже відсортований масив.
- Масив, що має дублікати.

Усі тести були пройдені успішно.

---

## Завдання 8.4

У цьому завданні було проаналізовано поведінку виклику `fork()` у простій програмі:

```c
int main() {
  int pid;
  pid = fork();
  printf("%d\n", pid);
}
```

Пояснення результату:  
- Якщо `fork()` успішний, то в батьківському процесі `pid` буде дорівнювати **PID дочірнього процесу** (>0).
- У дочірньому процесі `pid` буде дорівнювати **0**.
- Отже, вивід програми буде двома рядками чисел: одне — 0 (від дитини), інше — PID нового процесу (від батька).

Тобто програма друкує два значення, що належать різним процесам, які тепер працюють паралельно.

---

## Завдання 16

Було реалізовано програму для демонстрації **race condition** при спільному доступі до файлу без синхронізації.

Результати:
- Два процеси одночасно записували у спільний файл символи `'P'` та `'C'`.
- Через відсутність блокування дані у файлі змішувалися непередбачувано.
- Кожен запуск програми давав інший результат чергування символів.
- Іноді частина даних втрачалася або перезаписувалася.

Такий експеримент наочно показав, наскільки критичною є проблема синхронізації при спільному використанні ресурсів.

---

# Висновок

Виконання завдань дозволило на практиці ознайомитися з низькорівневими системними викликами ОС UNIX/POSIX, особливостями роботи з файлами, обробкою процесів та дослідженням алгоритмів.  
Було підтверджено, що навіть базові функції (такі як `write` і `read`) можуть працювати неочевидним чином у нестандартних умовах. Робота також показала важливість синхронізації при паралельній роботі з файлами та підкреслила практичні особливості системного програмування.
