# Практична робота №4

## Завдання 4.1: Максимальний розмір пам'яті, що може виділити malloc(3)

Було проаналізовано, який максимальний обсяг пам’яті може бути виділений за один виклик `malloc(3)`. Оскільки параметр `malloc(3)` є типу `size_t`, максимальний розмір визначається максимальною величиною `size_t`. На 64-бітній системі це 8 байтів (64 біти), що дає максимальний розмір `2^64` байтів (16 ексабайт). 

Однак, теоретично доступна пам’ять обмежена архітектурою процесора та операційною системою. Реальний ліміт значно менший через віртуальну пам’ять та обмеження ядра. 

На питання, чому теоретично максимальний обсяг складає 8 ексабайт, а не 16, відповідь полягає в тому, що сучасні процесори використовують лише 48-57 біт для адресації пам’яті, а не всі 64 біти.

## Завдання 4.2: Використання malloc(3) з від’ємним аргументом

Було досліджено, що станеться при передаванні `malloc(3)` від’ємного значення. Оскільки `malloc(3)` приймає `size_t` (беззнаковий тип), передача від’ємного числа призведе до переповнення та інтерпретації як великого позитивного числа, що спричинить невдале виділення пам’яті. 

Також було розглянуто випадок множення двох цілих чисел (`num = xa * xb`), де результат може перевищити межі `size_t`, викликаючи переповнення. `malloc(3)` у такому випадку може або повернути `NULL`, або викликати непередбачувану поведінку. Тестовий випадок продемонстрував помилку та необхідність перевірки переповнення перед передачею значення в `malloc(3)`.

## Завдання 4.3: Використання malloc(0)

Було протестовано, що станеться, якщо викликати `malloc(0)`. За стандартом C `malloc(0)` може повернути або `NULL`, або валідний вказівник, який можна передати `free()`. Поведінка залежить від реалізації `malloc(3)` у конкретній бібліотеці C. Тестовий випадок продемонстрував різну поведінку залежно від системи.

## Завдання 4.4: Аналіз помилки в коді з malloc(3)

Було проаналізовано наступний код:

```c
void *ptr = NULL;
while (<some-condition-is-true>) {
    if (!ptr)
        ptr = malloc(n);
    [... використання 'ptr' ...]
    free(ptr);
}
```

Помилка в тому, що `ptr` звільняється в кожній ітерації, але не скидається в `NULL`. Це може призвести до повторного використання звільненої пам’яті (use-after-free). Правильний варіант коду:

```c
void *ptr = NULL;
while (<some-condition-is-true>) {
    if (!ptr)
        ptr = malloc(n);
    [... використання 'ptr' ...]
    free(ptr);
    ptr = NULL;
}
```

## Завдання 4.5: Якщо realloc(3) не зможе виділити пам’ять

Було протестовано, що станеться, якщо `realloc(3)` не зможе виділити пам’ять. У такому випадку функція повертає `NULL`, але старий вказівник не звільняється. Важливо перед перевизначенням `ptr = realloc(ptr, new_size);` перевіряти, чи не повернув `realloc(3)` `NULL`, щоб уникнути втрати старої пам’яті.

## Завдання 4.6: Використання realloc(3) з NULL або розміром 0

Було перевірено дві ситуації:
1. `realloc(NULL, size)` – еквівалент `malloc(size)`. 
2. `realloc(ptr, 0)` – поводиться як `free(ptr)`, але може повернути або `NULL`, або валідний вказівник.

Тестування підтвердило таку поведінку, що узгоджується зі стандартом C.

## Завдання 4.7: Використання reallocarray(3)

Було переписано код, що використовував `realloc(3)`, замінивши його на `reallocarray(3)`, який перевіряє переповнення множення. 

Було проведено тестування через `ltrace`, що показало коректну роботу `reallocarray(3)` без ризику переповнення.

## Завдання 16: Реалізація memory pool

Було реалізовано простий пул пам’яті для об’єктів фіксованого розміру. Пул дозволяє швидко виділяти та звільняти пам’ять, використовуючи попередньо виділений блок. Це дозволяє зменшити фрагментацію пам’яті та прискорити виконання програми.

## Висновок

Правильне керування пам’яттю є критично важливим для стабільної та ефективної роботи програм. Використання `malloc(3)`, `realloc(3)`, `calloc(3)` та `reallocarray(3)` вимагає перевірки їхніх результатів та обережного поводження для запобігання витокам пам’яті, переповненню та use-after-free помилкам. `reallocarray(3)` забезпечує безпечніше виділення пам’яті, а memory pool допомагає оптимізувати роботу з часто використовуваними об’єктами. Тестування різних випадків виявило потенційні проблеми та дозволило розробити коректні рішення.

