# Практична робота №10-11
**Тема:** Process Creation у Linux

---

### Приклад (dumbsh.c): Мінімальна командна оболонка (Dumb Shell)

Було створено просту командну оболонку, яка зчитує команду від користувача, створює дочірній процес через `fork()` і виконує команду за допомогою `execlp()`. Після завершення дочірнього процесу, оболонка знову чекає введення. Передбачено завершення командою `exit`.

---

### Приклад (wait.c): Отримання коду завершення дочірнього процесу

Реалізовано приклад з використанням `wait()` та обробкою статусу через макроси `WIFEXITED()` та `WEXITSTATUS()`. Це дозволяє дізнатися, з яким кодом завершився дочірній процес.

---

### Приклад (children.c): Створення кількох дочірніх процесів

У циклі створено три дочірні процеси, кожен з яких виводить повідомлення та завершується. Батьківський процес чекає завершення кожного з них через `wait()`. Це демонструє шаблон керування кількома процесами.

---

### Завдання 16: Використання `waitpid()` з конкретним PID

Було реалізовано програму, що створює два дочірніх процеси, і батьківський чекає **лише один** з них, вказуючи його PID у `waitpid(pid, ...)`. Також додається `wait(NULL)` для уникнення зомбі-процесів. Це демонструє гнучке керування завершенням процесів.

---

### Висновок

У результаті виконання завдань вдалося глибше засвоїти механізми створення та керування процесами в Linux. Ключові моменти:

* `fork()` створює незалежну копію процесу (з незалежною пам’яттю, але спільними файловими дескрипторами).
* `wait()` і `waitpid()` дозволяють коректно завершувати процеси, запобігаючи утворенню зомбі.
* `execlp()` дозволяє запускати зовнішні програми в дочірньому процесі.
* Системний виклик `waitpid()` дозволяє тонко керувати тим, кого чекати і коли.

Здобуті навички дозволяють створювати прості багатопроцесні додатки, shell-подібні інтерфейси, а також контролювати життєвий цикл процесів в Unix-подібних системах.