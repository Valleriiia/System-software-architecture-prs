# Практична робота №14
**Тема:** Timers

---

## Приклад: POSIX interval timer

У цьому прикладі було реалізовано простий таймер з використанням сучасного POSIX-інтерфейсу `timer_create`, `timer_settime` та `sigaction` з `SIGRTMIN`. Таймер налаштовувався на спрацювання кожну секунду, після чого в обробнику сигналу виводилось повідомлення `"Tick\n"` у стандартний потік виводу. Код використовував структуру `sigevent` для налаштування генерації сигналу, а також асинхронну обробку через `sa_sigaction`.

---

## Завдання 16: Написати власний аналог cron**

Було реалізовано простий аналог системного планувальника `cron`, який використовує POSIX-таймери для запуску зовнішніх команд у фоновому режимі з заданими інтервалами. Програма дозволяє створити масив завдань (команд), кожна з яких запускається з власним інтервалом за допомогою окремого `timer_t`.

Всі таймери працюють через сигнал `SIGRTMIN`, унікальний для кожного виклику, що дозволяє передавати в обробник сигналу посилання на відповідну задачу (`sival_ptr`). Обробник сигналу запускає відповідну команду в окремому процесі через `fork()` + `execlp()`, при цьому батьківський процес очікує завершення дочірнього.

---

## Висновок

У ході виконання практичної роботи було повністю освоєно роботу з POSIX-таймерами, включно зі створенням, налаштуванням, повторним запуском та обробкою сигналів. Також була здобута практика з асинхронною обробкою подій у системному програмуванні, зокрема з використанням реальних сигналів (`SIGRTMIN`) і механізму передачі параметрів до обробника. Особливо цінною стала реалізація аналога `cron`, яка продемонструвала можливості POSIX-таймерів як надійного інструмента для періодичних та відкладених задач без використання потоків чи циклів затримки.

Отриманий досвід дає міцну базу для розробки систем рівня ОС, фонових сервісів, планувальників, або подієвих систем, у тому числі з використанням `epoll`, `timerfd_create` або `signalfd` у майбутніх проектах.
